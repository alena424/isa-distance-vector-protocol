
RIP protocol

<title page>

<obsah>

<Implementation>

<Testing>

<Conclusion>

<Bibliographies>
https://learningnetwork.cisco.com/thread/30426
1. https://www.ietf.org/rfc/rfc1923.txt
2. https://www.cisco.com/c/en/us/support/docs/ip/routing-information-protocol-rip/13719-50.html
3. https://tools.ietf.org/html/rfc1826
4. https://tools.ietf.org/html/rfc1827
5. * RFC2080 - RIPng for IPv6 (http://tools.ietf.org/html/rfc2080)

* RFC1058 - RIP version 1 (http://tools.ietf.org/html/rfc1058)
* RFC2453 - RIP version 2 (http://tools.ietf.org/html/rfc2453)
* RFC2080 - RIPng for IPv6 (http://tools.ietf.org/html/rfc2080)
* str√°nky knihovny libpcap (http://www.tcpdump.org/)
-------------------------------------------------------------

<Introduction>
Our main task was to deeply study routing protocols RIP, RIP2 and RIPng. After that, we implemented sniffer RIPv1, RIPv2 and RIPng messages, faker that sends response messages to router and perform a success attack.

<Abstract>
In internet it is not likely to have one single protocol that is used for the entire network. Rather, network is divided into autonomous systems (AS) where each AS has its own routing technology. Although there are many types of protocol that determines communication between nodes, we can divide them into 2 groups Interior gateway protocol(IGP) and Exterior gateway protocol(EGP). IGP is a routing protocol used in AS and a EGP is used to transfer information among ASs. RIP is designed to work as an IGP in moderate-size AS.  

<RIP>
RIP is a distance-vector routing protocol used in smaller networks, that sends the complete routing table out to all interfaces every 30 seconds. RIPv1 only uses hops to determine the best way to a remote network. However there is a maximum hop count of 15 by default (16 means unreachable). RIP version 1 uses mechanism called classful routing meaning that all devices in the network must use same subnet mask. The reason is that RIPv1 doesn't send updates with subnet mask information. On the other hand RIPv2 provides classful routing and sends subnet mask with the route updates.

<Comparison between RIPV1 and RIPV2>
Current RIPv1 contains a small amount of information that is necessary for routers to route message through network. It does not consider autonomous systems, IGP interactions, subnetting and authentication. The most serious problem is lack of subnet masks. Routers need a mask to know how to determine a route.

RIPs are based on a Bellman-Ford algorithm.
Contains 2 types of messages:

request 
- ask for response containing all OR part of a routers routing table  
- normally send as multicast (RIPv1 broadcast) but can be a situation that we need to send to just one response to just one router (posible with RIPng) then packet is sent directly to the router from a UDP port other that the RIPng port
- if there is one entry in the request, destination prefix is zero, a prefix length is zero, metric of infinity 16, then this is request to send entire routing table

response
A response A message containing all or part of the sender's routing table.  It can be sent in response to a request or it may be a routing update generated by the sender.
There 3 reasons to send a reponse:
- response to a query
- regular update
- triggered update caused by a route change

Common limitations:
1. Maximum of 15 hops
2. Counting to infinity to resolve certain unusual situations (loop -> require either much time or bandwidth)
3. Uses fixed metrics (no real time factors as delay, reliability, load)

<Comparison between RIPV1 and RIPV2>
RIPV1
- No authentication
- No support for discontiguous networks
- classful
- broadcast based
- no support for VLSM (variable long subnet mask)

RIPV2
- allows MD5 authentication
- supports discontiguous networks
- classless
- uses multicast 244.0.0.9
- support for VLSM

discontiguous https://learningnetwork.cisco.com/thread/30426

To conclusion RIPv2 is an advanced RIPv1 which can be used in small networks or at the edge of larger networks because of its simplicity in usage and configuration.

Nowadays, RIPv2 is

RIPv2
<Authentication>
Security is one of the primary concerns of network designers today (2). Our main concern in RIP protocols is to ensure that information entered into the routing table is valid or not. An attacker can easily send a malicious packet that will be sent to network and might end up in the routing table due to poor configuration. Because of this, it's necessary to authenticate the routing update process. Either we can authenticate an update with Simple or MD5 authentication. The difference is clear, the simple password is sent through network as a plain text for everybody to see compared to MD5 which sends encrypted data to be decode by a specific authentication algorithm.

MD5 authentication
Configuration of MD5 contains of:
1. defining a key chain with a name that determines the set of keys that can be used on the interface
2. defining the key or keys on the chain (related to number 1)
3. defining the key string to be used in the key, needs to be same on remote routers, the actual password
4. enable authentication on the interface and specify the key chain + type of authentication (MD5)

Apart from type number 3 in Key Keyed Message Digest, routing update contains:
1. 16 bits Authentication data
2. 8 bit field contains Key Identifier or Key id
3. 8 bit field contains the length of data field
4. 32 bit sequence number -> must be non-decreasing for all message with same key ID

Verification uses MD5 hash algorithm using a password which routing updates does not carry (that makes is authenticate). Rather, it carries a 16 bites message, generated by the MD5 algorithm on the password.

Structure of RIPv2
RIP protocols are designed to have one header (4 B) and several entries (each 20 B). RIP header contains information as version of RIP and command (either request or response). In entries we find address family identifier (AFI) describing type of address (2 B), route tag (2 B), which differs external rip routes from internal or it can be also a type of authentication. If an address family identifier equals 0xFFFF, then according to the authentication type we parse authentication data (16 B). To see more information about authentication go to section XXX. If AFI equals value of AF_INET, than subnet mask (4 B), destination IPv4 address (4 B), next hop (4 B) and the cost to reach that destination (metric, 4 B) are sent.

!! explanation!!!
2. next hop - ipv6 address of next router along the path to the destination


RIPng 
Protocol RIPng is a routing protocol implemented for IPv6 networking. In comparison with RIPv2 there is no authentication, RIPng relies on the IP Authentication Header (3) and the IP Encapsulating Security Payload (4)(5). Structure is similar to RIPv4 described in XXX, but instead of sending subnet mask, a prefix length is sent. 

Controls
There are more controls on RIP packet that we have to keep in mind while programing RIP.
Response must be ignored if:
- ip address is not from right UDP port
- ip source is from a valid neighbor
- source of datagram must be from link local address
- if the metric is greater than 16, ignore the entry but log the event

Process of setting a route to routing table
- set destination prefix and length in RTE (routing table entry)
- set metric to the newly calculated metric
- set the next hop address to be the address from which the datagram came or is specified by a next hop in RTE
- initialized the timeout
- set the route change flag
- signal the output process to trigger an update

if there is an existing router -> compare next hop -> if next hop is from the same router as the existing router -> update timer
if metric is lower -> put the next metric in, adjust IP address, set the route change flag, if infinity start the deletion process

Implementation details
Sniffer
./myripsniffer -i <interface>
example ./myripsniffer -i eth0

Structure
sniffer.c - contains functions to parse and print RIP packets (RIPv1, RIPv2, RIPng)
headers.h - contains RIP packets headers
sniffer_h.h - contains headers of functions belonging to RIP sniffer
myripsniffer.c - main file which starts capturing packets

For capturing packets I was using functions from libpcap library. Firstly is important to set an interface, open a handle and apply a filter. Chosen filter was udp port 520 or udp port 521 that corresponds to RIPv1, RIPv2 and RIPng protocols. In an immense loop (function pcap_loop) I was parsing packets a printing all important information (function print_packet). Thanks to libraries as ip.h, udp.h I did not have to implement structure of udp and ip protocol. I implemented RIP structures described in XXX in headers.h and had to distinguish IPv4 packet from IPv6 packet (functions ipv6_process and ipv4_process). Due to fact that we know a routing table entry length and length of RIP packet, we can loop till actual parsing length is equal or greater than rip length. In a loop we parse RIP entry, for IPv2 we must not forget types of authentication (see more in section XXX).

RIP response
./myripresponse -i <interface> -r <IPv6>/[16-128] {-n <IPv6>} {-m [0-16]} {-t [0-65535]}
example ./myripresponse -i eth0 -r 2001:db8:0:abcd::/64 

Structure
myripresponse.c - main file for rip response, parse and process all arguments
response.c - file to create and send rip packet
response.h - contains used response structures

This part of project is shorter than the first one. It is composed of 2 parts - parsing arguments and sending a RIPng packet. This packet contains of one RIP header and two routing table entries. In header we set response command and version one. First entry contains information given on input (route tag, prefix, number of hops, metric) and the second contains next hop with metric of value of 0xFF (5). Next hop is set according to input or default next hop is used (::).
While creating an UDP packet, we set a receivers address to multicast group FF02::9, RIPng port 521, interface index, hop limit of 255 (maximum hop limit), AFI and receivers IPv6 address to any.

Testing
<Settings>
On my computer I have 2 virtual machines with FreeBSD (given from school) and Ubuntu that I run on VirtualBox (url). Both machines are set on internal network with same name of the network to be able to see each other. While testing, I run Wireshark on Ubuntu and compare results with my program. As a result I can valid displayed data. For testing MD5 I use a tool tcpreplay with given pcap file because no MD5 authentication is implemented on FreeBSD.   

<Sniffer>
Sniffer needs to be compatible with RIPv1, RIPv2 and RIPng. Because of it I use a filter that captures packets on UDP port 520 and 521.

RIPv2 header
 Length 126, received at Sat Nov 17 02:36:16 2018
      Source MAC: aa:bb:cc:0:2:0, Destination MAC: aa:bb:cc:0:2:0
      IP: id 0x0, hlen 20 bytes, version 4, total length 112 bytes, TTL 2
      IP: version 4, total length 112 bytes, TTL 2
      IP src = 10.0.0.2, IP dst = 224.0.0.9, protocol UDP (17)

RIPv2 - Routing information data
RIPv2 simple
      == Routing information protocol ==
      Command: RESPONSE, Version: RIPv2
      Rip length: 84
      Authentication type: Simple Password (2)
      Password: cisco
      IP address: 10.2.21.0, Metric: 8
      Address family identif: IP (2), Route Tag: 0
      Netmask: 255.255.255.0
      Next hop: 0.0.0.0

      IP address: 10.2.22.0, Metric: 8
      Address family identif: IP (2), Route Tag: 0
      Netmask: 255.255.255.0
      Next hop: 0.0.0.0

      IP address: 10.2.23.0, Metric: 8
      Address family identif: IP (2), Route Tag: 0
      Netmask: 255.255.255.0
      Next hop: 0.0.0.0

RIPv2 MD5

Length 146, received at Sat Nov 17 02:36:16 2018
      == Routing information protocol ==
      Command: RESPONSE, Version: RIPv2
      Rip length: 104
      Authentication type: Key Message Digest (3)
      Digest Offset: 84, Key ID: 1
      Auth Data Len: 20, Seq num: 20
      IP address: 10.1.11.0, Metric: 3
      Address family identif: IP (2), Route Tag: 0
      Netmask: 255.255.255.0
      Next hop: 0.0.0.0

      IP address: 10.1.12.0, Metric: 3
      Address family identif: IP (2), Route Tag: 0
      Netmask: 255.255.255.0
      Next hop: 0.0.0.0

      IP address: 10.1.13.0, Metric: 3
      Address family identif: IP (2), Route Tag: 0
      Netmask: 255.255.255.0
      Next hop: 0.0.0.0

      Authentication data: 6946f20b014d173031dd1d2e48e9af37

RIPng
      == Routing information protocol ==
      Command: RESPONSE, Version: 1
      Rip length: 84
      Route Tag: 0
      IPv6 address: fd10:1:21::
      Prefix Length: 64
      Metric: 1

      Route Tag: 0
      IPv6 address: fd10:1:22::
      Prefix Length: 64
      Metric: 1

      Route Tag: 0
      IPv6 address: fd10:1:23::
      Prefix Length: 64
      Metric: 1

      Route Tag: 0
      IPv6 address: fd10::
      Prefix Length: 64
      Metric: 1

<all captured route from FreeBSD>
RIPv2
IP address: 10.48.48.0 (255.255.255.0)
IP address: 10.103.211.0 (255.255.255.0)
IP address: 10.111.105.0 (255.255.255.0)
IP address: 10.216.110.0 (255.255.255.0)

RIPng
IPv6 address: fd00:d5:3390::/64
IPv6 address: fd00:108:2c4c::/64
IPv6 address: fd00:4d4:6c::/64
IPv6 address: fd00:900:14d0::/64

<fake RIP response packet>
sudo ./myripresponse -i enp0s3 -r  2001:db8:0:abcd::/64

<wireshark picture>

Conclusion
To summarize I can say that I 

Bibliographies
