RIP protocol

<title page>

<obsah>

<Implementation>

<Testing>

<Conclusion>

<Bibliografie>
https://learningnetwork.cisco.com/thread/30426
1. https://www.ietf.org/rfc/rfc1923.txt
2. https://www.cisco.com/c/en/us/support/docs/ip/routing-information-protocol-rip/13719-50.html

* RFC1058 - RIP version 1 (http://tools.ietf.org/html/rfc1058)
* RFC2453 - RIP version 2 (http://tools.ietf.org/html/rfc2453)
* RFC2080 - RIPng for IPv6 (http://tools.ietf.org/html/rfc2080)
* str√°nky knihovny libpcap (http://www.tcpdump.org/)
-------------------------------------------------------------

<Introduction>
Our main task was to deeply study routing protocols RIP, RIP2 and RIPng. After that, we implemented sniffer RIPv1, RIPv2 and RIPng messages, faker that sends response messages to router and perform a success attack.

<Abstract>
In internet it is not likely to have one single protocol that is used for the entire network. Rather, network is devided into autonomous systems (AS) where each AS has its own routing technology. Although there are many types of protocol that determines communication beetween nodes, we can devide them into 2 groups Interior gateway protocol(IGP) and Exterior gateway protocol(EGP). IGP is a routing protocol used in AS and a EGP is used to transfer information among ASs. RIP is designed to work as an IGP in moderate-size AS.  

<RIP>
RIP is a distance-vector routing protocol used in smaller networks, that sends the complete routing table out to all interfaces every 30 seconds. RIPv1 only uses hops to determine the best way to a remote network. However there is a maximum hop count of 15 by default (16 means unreachable). RIP version 1 uses mechanism called classful routing meaning that all devices in the network must use same subnet mask. The reason is that RIPv1 doesn't send updates with subnet mask information. On the other hand RIPv2 provides classful routing and sends subnet mask with the route updates.

<Comparison between RIPV1 and RIPV2>
Current RIPv1 not enought amount of information that are necessary for routers to route message through a network. It does ot consider autonomous systems, IGP interactions, subnetting and authentication. The most serious problem is lack of subnet masks. Routers need a mask to know how to determine a route.

RIPs are based on a Bellman-Ford algorithm. 
Contains 2 types of messages:
request    A request for the responding system to send all or
                  part of its routing table.

response   A message containing all or part of the sender's
                  routing table.  This message may be sent in response
                  to a request, or it may be an unsolicited routing
                  update generated by the sender.

Commion limitations:
1. maximum of 15 hops
2. counting to infinity to resolve certain unusual situations (loop -> require either much time or bandwidth)
3. uses fixed metrics (no real time factors as delay, reliability, load)

<Comparison between RIPV1 and RIPV2>
RIPV1
- No authentication
- no support for discontiguous networks
- classful
- broadcast based
- no support for VLSM (variable long subnet mask)

RIPV2
- allows MD5 authentication
- supports discontiguous networks
- classless
- uses multicast 244.0.0.9
- support for VLSM

discontiguous https://learningnetwork.cisco.com/thread/30426

To conclusion RIPv2 is an advanced RIPv1 which can be used small, netwoks or at the edge of larger networks because of its simplicity in usage and configuration.

Nowadays, RIPv2 is 

RIPv2
<Authentication>
Security is one of the primary concerns of network designers today (2). Our main concern in RIP protoocols is to ensure that information entered into the routing table is valid or not. An attacker can easily send fake rip update that will be sent to network and might end up in the routing table due to poor configuration. Because of this, it's necasarry to authenticate the routing update process. Either we can authenticate an update with Simple or MD5 authentication. The difference is clear, the simple password is sent through networt as a plain text for everybody to see compared to MD5 which sends encrypted data to be decode by a specific authentication algorithm.

MD5 authentication
Configuration of MD5 contains of:
1. defining a key chain with a name that determines the set of keys that can be used on the interface
2. defining the key or keys on the chain (related to number 1)
3. defining the key string to be used in the key, needs to be same on remote routers, the actual password
4. enable authentication on the interface and scpecify the key chain + type of authentication (MD5)

Apart from type number 3 in Key Keyed Message Digest, routing update contains:
1. 16 bits Auhentication data
2. 8 bit field contains Key Identifier or Key id
3. 8 bit field contains the length of data field
4. 32 bit sequince number -> must be non decreasing for all message with same key ID

Verification uses MD5 hash algorithm using a password which routing updates does not carry (that makes is autenticate). Rather, it carries a 16 bites message, generated by the MD5 algorithm on the password.

RIPng - implementation details

<Ripng general>
Entry:
1. metric - cost of getting a datagram from the router to that destination
2. next hop - ipv6 address of next router along the path to the destination 
3. route change flag - flag to indicate if the route changed recently
4. timers [sec. 2.3.]

destination prefix - 128bits -> 16bytes
route tag - differs external ripng routes and internal ex. number of Autonomous Systems from which the routes were learned
prefix length - contains a value between 0 and 128 inclusive
			- 0 means default route, prefix should be 0:0:0:0:0:0:0:0
next hop	- is identified if metric equals 0xFF that route tag and prefix length must be zero
			- purpose: eliminate packets being routed through extra hops in the systems, if not link local should be treated as 0:0:0:0:0:0:0:0:0:0 (8x)

timers
- every 30 seconds updates are triggered
- the 30 second timer is offset by a small random time +/- 0 to 15 seconds
- timeout - after timeout, the route is no longer valid, remains in routing table for a short time so the neighbors can be notified that the routers has been dropped
-> upon expiration of the garbage-collector timer, the route is finally removed from the routing table  

timeout initialized
1. when route is established
2. any time an update message is received for the route
! of 180 seconds elapse from the last time the timeout was initialized -> the route is considered as expired -> starts deletion process

Deletions
2 reasons: the timeout expires, metric is set to 16 because of an update received from the correct router

1. garbage-collector timer is set to 120 seconds
2. metric for the route is 16 infinity
3. the flag is set that this entry has been changed
4. the output process is signaled to trigger a response

until the garbage collector expires, the route is included in all updates sent BY this router. When expires -> the route is deleted from the routing table

Request message
- ask for response containing all or part of a routers routing table.
- normally send as multicast BUT can be a situation that we need to send to just one response to just one router -> packet is sent directly to the router from a UDP port other that the RIPng port
- if the re no entries no response is given
--> one special case: one entry in the request, dictation prefix is zero, a prefix length is zero, metric of infinity 16, then this is request to send ENTIRE routing table

Response
3 reasons
- response to a query
- regular update
- triggered update caused by a route change

controls
response must be ignored if:
- ip address is not from right UDP port
- ip source is from a valid neighbor
- the source of datagram must be from link local address

If the metric is greater than 16, ignore the entry but log the event

Test validations:
- is the destination prefix valid, a link local address should never be in an RTE
- is the prefix length valid 0 - 128
- is the metric valid 1-16


metric = MIN (metric + cost, infinity)

Process of setting a route to routing table
- set destination prefix and length in RTE (routing table entry)
- set metric to the newly calculated metric
- set the next hop address to be the address from which the datagram came or is specified by a next hop in RTE
- initialized the timeout
- set the route change flag
- signal the output process to trigger an update

if there is an existing router -> compare next hop -> if next hop is from the same router as the existing router -> update timer
if metric is lower -> put the next metric in, adjust hp address, set the route change flag, if infinity start the deletion process

response message is multicast group FF02::9

poison reverse - loop, we poison one router e.g. set metric to infinity

Testing
<settings>
On my computer I have a 2 virtual machines with FReeBSD (given from school) and Ubuntu that I run on VirtualBox (url). Both machines are set on internal network with same name of the network to be able to see each other. While testing, I run Wireshark on ubuntu and compare results with my program. As a result I can valide displayed data. For testing MD5 I use a tool tcpreplay with given pcap file because no MD5 authentication is implemented on FreeBSD.   

<sniffer>
Sniffer needs to be compatible with RIPv1, RIPv2 and RIPng. Because of it I use a filter that captures packets on udp port 520 and 521.

RIPv2 header
 Length 126, received at Sat Nov 17 02:36:16 2018
      Source MAC: aa:bb:cc:0:2:0, Destination MAC: aa:bb:cc:0:2:0
      IP: id 0x0, hlen 20 bytes, version 4, total length 112 bytes, TTL 2
      IP: version 4, total length 112 bytes, TTL 2
      IP src = 10.0.0.2, IP dst = 224.0.0.9, protocol UDP (17)

RIPv2 - Routing information data
RIPv2 simple
      == Routing information protocol ==
      Command: RESPONSE, Version: RIPv2
      Rip length: 84
      Authentication type: Simple Password (2)
      Password: cisco
      IP address: 10.2.21.0, Metric: 8
      Address family identif: IP (2), Route Tag: 0
      Netmask: 255.255.255.0
      Next hop: 0.0.0.0

      IP address: 10.2.22.0, Metric: 8
      Address family identif: IP (2), Route Tag: 0
      Netmask: 255.255.255.0
      Next hop: 0.0.0.0

      IP address: 10.2.23.0, Metric: 8
      Address family identif: IP (2), Route Tag: 0
      Netmask: 255.255.255.0
      Next hop: 0.0.0.0


RIPv2 MD5

Length 146, received at Sat Nov 17 02:36:16 2018
      == Routing information protocol ==
      Command: RESPONSE, Version: RIPv2
      Rip length: 104
      Authentication type: Key Message Digest (3)
      Digest Offset: 84, Key ID: 1
      Auth Data Len: 20, Seq num: 20
      IP address: 10.1.11.0, Metric: 3
      Address family identif: IP (2), Route Tag: 0
      Netmask: 255.255.255.0
      Next hop: 0.0.0.0

      IP address: 10.1.12.0, Metric: 3
      Address family identif: IP (2), Route Tag: 0
      Netmask: 255.255.255.0
      Next hop: 0.0.0.0

      IP address: 10.1.13.0, Metric: 3
      Address family identif: IP (2), Route Tag: 0
      Netmask: 255.255.255.0
      Next hop: 0.0.0.0

      Authentication data: 6946f20b014d173031dd1d2e48e9af37

RIPng
      == Routing information protocol ==
      Command: RESPONSE, Version: 1
      Rip length: 84
      Route Tag: 0
      IPv6 address: fd10:1:21::
      Prefix Length: 64
      Metric: 1

      Route Tag: 0
      IPv6 address: fd10:1:22::
      Prefix Length: 64
      Metric: 1

      Route Tag: 0
      IPv6 address: fd10:1:23::
      Prefix Length: 64
      Metric: 1

      Route Tag: 0
      IPv6 address: fd10::
      Prefix Length: 64
      Metric: 1

<all captured route from freeBSD>
RIPv2
IP address: 10.48.48.0 (255.255.255.0)
IP address: 10.103.211.0 (255.255.255.0)
IP address: 10.111.105.0 (255.255.255.0)
IP address: 10.216.110.0 (255.255.255.0)

RIPng
IPv6 address: fd00:d5:3390::/64
IPv6 address: fd00:108:2c4c::/64
IPv6 address: fd00:4d4:6c::/64
IPv6 address: fd00:900:14d0::/64


<fake RIP response packet>
sudo ./myripresponse -i enp0s3 -r  2001:db8:0:abcd::/64

<wireshark picture>


